var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>A library to help with atomic processing of lines. Some libraries are a bit fuzzy on what happens if a call to <code>readline</code> times out (is the partial read data consumed? Is a partial read returned?). This can be used  as an adapter for such libraries as long as they have an ordinary <code>read</code> call.</p>"},{"location":"index.html#overview","title":"Overview","text":"<p>The AtomicLineReader provides a sane <code>readline</code> function internally. LineProcessor extends this by running an AtomicLineReader][atomiclines.atomiclinereader.AtomicLineReader] and then running any user provided processing function on each line.</p> <p>The library is implemented as async.</p>"},{"location":"index.html#example","title":"Example","text":"<p>Assume you would like to do read lines from the serial port asynchronously.</p> Note <p>Accoridng to my best knowledge cross platform async access to the serial port is hard, and is the reason why this was created (and for me to have a proper play with async ;) )</p> <pre><code>import asyncio\nimport aioserial\nfrom atomiclines.lineprocessor import LineProcessor\nclass SerialReadable:\n\"\"\"A wrapper to back up AioSerial so that the interface matches\n    LineProcessor/AtomicLineReader's expectations.\"\"\"\ndef __init__(self, port):\nself._serial = aioserial.AioSerial(port=port, baudrate=115200)\nasync def read(self):\nreturn await self._serial.read_async()\nasync def main():\nreadable = SerialReadable(\"/dev/ttyUSB0\")\nprocessor = LineProcessor(readable)\nprocessor.add_processor(print)  # (1)!\nasync with processor:  # (2)!\nreadable._serial.write(b\"help\\r\\n\")  # (3)!\nawait asyncio.sleep(3600)\nif __name__ == \"__main__\":\nasyncio.run(main())\n</code></pre> <ol> <li>We just print every line, like a terminal</li> <li>I am a strong believer in preventing users from forgetting to do cleanup through the use of contextmanagers.     Otherwise cleanup might be ommitted, like the closing of the AioSerial port in this example.</li> <li>A command which the serial counterpart hopefully understands</li> </ol>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>atomiclines<ul> <li>atomiclinereader</li> <li>backgroundtask</li> <li>exception</li> <li>lineprocessor</li> <li>log</li> </ul> </li> </ul>"},{"location":"reference/atomiclines/index.html","title":"atomiclines","text":"<p>The atomic-lines package.</p>"},{"location":"reference/atomiclines/index.html#atomiclines.AtomicLineReader","title":"<code>AtomicLineReader</code>","text":"<p>             Bases: <code>BackgroundTask</code></p> <p>Read lines atomically.</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>class AtomicLineReader(BackgroundTask):\n\"\"\"Read lines atomically.\"\"\"\n_reader_task: asyncio.Task\n_reader_active: bool\n_eol: bytes\n_instances: int = 0\ndef __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Generate a reader.\n        Args:\n            streamable: object which provides an async read method, returning one byte\n        \"\"\"\nself._buffer = bytearray()  # TODO ringbuffer, that exposes a memoryview\nself._event_byte_received = asyncio.Event()\nself._streamable = streamable\nself._reader_active = False\nself._eol = b\"\\n\"\nself._instance_id = self._instances\nAtomicLineReader._instances += 1  # noqa: WPS437 - \"private\" access is intended\nsuper().__init__()\n# TODO: allow setting a default timeout\n@property\ndef buffer(self) -&gt; bytes:\n\"\"\"Peek the byte buffer.\n        Returns:\n            bytes currently held in buffer\n        \"\"\"\nreturn self._buffer\nasync def readline(self, timeout: float | None = None) -&gt; bytes:\n\"\"\"Read a single line or raise a timeout error.\n        Args:\n            timeout: timeout in seconds. Defaults to None.\n        Raises:\n            LinesTimeoutError: if the buffer does not contain an end of line character\n                before the timeout expires\n        Returns:\n            the next line from the buffer (!without the eol character)\n        \"\"\"\n# TODO: should we return a Timeout error or an IncompleteReadError?\nif timeout == 0:\nif self._buffer.find(self._eol) == -1:\nraise LinesTimeoutError(timeout)\n# TODO: asyncio.IncompleteReadError(self._buffer.copy(), None)\nelse:\nawait self._wait_for_line(timeout)\nline, _, buffer = self._buffer.partition(self._eol)\nself._buffer = buffer\nreturn line\ndef start(self) -&gt; None:\n\"\"\"Start the background reader process.\n        Prefer using this as a context manager whenever you can.\n        \"\"\"\nsuper().start()\nself.task.add_done_callback(lambda task: self._event_byte_received.set())\nasync def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop reading.\n        Args:\n            timeout: Timeout for a gracefull shutdown. Defaults to 0.\n        \"\"\"\nself.signal_stop()\nawait super().stop(timeout)\nasync def _background_job(self) -&gt; None:\nwhile not self._background_task_stop:\nbytes_read = await self._streamable.read()\nself._buffer.extend(bytes_read)\nif self._eol in bytes_read:\nold_data_end = -len(bytes_read)\nline_start = self._buffer.rfind(self._eol, None, old_data_end) + 1\nline_end = self._buffer.find(self._eol, line_start)\nwhile line_end != -1:\nlogger.info(bytes(self._buffer[line_start:line_end]))\nline_start = line_end + 1\nline_end = self._buffer.find(self._eol, line_start)\nself._event_byte_received.set()\nasync def _wait_for_line(self, timeout: float | None = None) -&gt; None:\nasync with asyncio.timeout(timeout):\nwhile self._buffer.find(self._eol) == -1:\nawait self._event_byte_received.wait()\nself._event_byte_received.clear()\nif not self.background_task_active:\nraise LinesProcessError()\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.AtomicLineReader.buffer","title":"<code>buffer: bytes</code>  <code>property</code>","text":"<p>Peek the byte buffer.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes currently held in buffer</p>"},{"location":"reference/atomiclines/index.html#atomiclines.AtomicLineReader.__init__","title":"<code>__init__(streamable)</code>","text":"<p>Generate a reader.</p> <p>Parameters:</p> Name Type Description Default <code>streamable</code> <code>Readable</code> <p>object which provides an async read method, returning one byte</p> required Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>def __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Generate a reader.\n    Args:\n        streamable: object which provides an async read method, returning one byte\n    \"\"\"\nself._buffer = bytearray()  # TODO ringbuffer, that exposes a memoryview\nself._event_byte_received = asyncio.Event()\nself._streamable = streamable\nself._reader_active = False\nself._eol = b\"\\n\"\nself._instance_id = self._instances\nAtomicLineReader._instances += 1  # noqa: WPS437 - \"private\" access is intended\nsuper().__init__()\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.AtomicLineReader.readline","title":"<code>readline(timeout=None)</code>  <code>async</code>","text":"<p>Read a single line or raise a timeout error.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>timeout in seconds. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>LinesTimeoutError</code> <p>if the buffer does not contain an end of line character before the timeout expires</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the next line from the buffer (!without the eol character)</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>async def readline(self, timeout: float | None = None) -&gt; bytes:\n\"\"\"Read a single line or raise a timeout error.\n    Args:\n        timeout: timeout in seconds. Defaults to None.\n    Raises:\n        LinesTimeoutError: if the buffer does not contain an end of line character\n            before the timeout expires\n    Returns:\n        the next line from the buffer (!without the eol character)\n    \"\"\"\n# TODO: should we return a Timeout error or an IncompleteReadError?\nif timeout == 0:\nif self._buffer.find(self._eol) == -1:\nraise LinesTimeoutError(timeout)\n# TODO: asyncio.IncompleteReadError(self._buffer.copy(), None)\nelse:\nawait self._wait_for_line(timeout)\nline, _, buffer = self._buffer.partition(self._eol)\nself._buffer = buffer\nreturn line\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.AtomicLineReader.start","title":"<code>start()</code>","text":"<p>Start the background reader process.</p> <p>Prefer using this as a context manager whenever you can.</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the background reader process.\n    Prefer using this as a context manager whenever you can.\n    \"\"\"\nsuper().start()\nself.task.add_done_callback(lambda task: self._event_byte_received.set())\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.AtomicLineReader.stop","title":"<code>stop(timeout=0)</code>  <code>async</code>","text":"<p>Stop reading.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Timeout for a gracefull shutdown. Defaults to 0.</p> <code>0</code> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>async def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop reading.\n    Args:\n        timeout: Timeout for a gracefull shutdown. Defaults to 0.\n    \"\"\"\nself.signal_stop()\nawait super().stop(timeout)\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask","title":"<code>BackgroundTask</code>","text":"<p>Read lines atomically.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>class BackgroundTask:\n\"\"\"Read lines atomically.\"\"\"\n_background_task: asyncio.Task | asyncio.Future\ndef __init__(self) -&gt; None:\n\"\"\"Generate a reader.\"\"\"\nself._background_task = DoneTask()\n@property\ndef background_task_active(self) -&gt; bool:\n\"\"\"Check if the background task is (still) running.\n        Returns:\n            bool indication if the background task is running.\n        \"\"\"\nreturn not self._background_task.done()\ndef start(self) -&gt; None:\n\"\"\"Start the reader coroutine.\"\"\"\nif not self.background_task_active:\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself._background_task_stop = False\nself._background_task = asyncio.create_task(self._background_job())\nself._background_task.add_done_callback(\nlambda task: self._job_exit_check(task),\n)\ndef signal_stop(self) -&gt; None:\n\"\"\"Request a soft stop of the background thread.\"\"\"\nlogger.debug(\nf\"Signaling stop to background task for {super()!r}\",\n)\nself._background_task_stop = True\nasync def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the reader coroutine.\n        Raises any errors which might have occured in the background task.\n        Raises:\n            LinesTimeoutError: timeout occured\n        Args:\n            timeout: timeout in seconds before the reader process is forcefully\n                cancelled.\n        \"\"\"\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself.signal_stop()\nif timeout == 0:\nself._background_task.cancel()\nwith contextlib.suppress(asyncio.CancelledError):\nawait asyncio.wait_for(self._background_task, 0.1)\nreturn\ntry:\nawait asyncio.wait_for(self._background_task, timeout)\nexcept TimeoutError as timeout_exception:\nlogger.debug(\nf\"Cancelled background task for {super()!r} after {timeout} \"\n+ \"second timeout.\",\n)\nraise LinesTimeoutError(timeout) from timeout_exception\n@property\ndef task(self) -&gt; asyncio.Future:\n\"\"\"Get the background task.\n        Usefull for adding done callbacks (add_done_callback).\n        Returns:\n            the background task object\n        \"\"\"\nreturn self._background_task\nasync def __aenter__(self) -&gt; Self:\n\"\"\"Asynchronous context manager, which starts the reader.\n        Returns:\n            AtomicLineReader instance\n        \"\"\"\nself.start()\nreturn self\nasync def __aexit__(\nself,\n_exc_type: Type[BaseException] | None,\n_exc_val: BaseException | None,\n_exc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Close the asynchronous context manager and stop the reader.\"\"\"\nawait self.stop()\n# @abstractmethod\nasync def _background_job(self) -&gt; None:\n\"\"\"Function to run in the background (as an Asyncio task).\n        A typical implemntation should check on self._background_task_stop,\n        since this is used to signal a soft stop.\n        while not self._background_task_stop:\n            doSomething()\n        Raises:\n            NotImplementedError: _description_\n        \"\"\"  # noqa: D401\nraise NotImplementedError\ndef _job_exit_check(self, task: asyncio.Task) -&gt; None:\nwith contextlib.suppress(asyncio.CancelledError):\nif task.exception() is not None:\nlogger.error(\nf\"An error occured in the background process. {task.exception()}\",\n)\nlogger.error(traceback.format_exception(task.exception()))\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.background_task_active","title":"<code>background_task_active: bool</code>  <code>property</code>","text":"<p>Check if the background task is (still) running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool indication if the background task is running.</p>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.task","title":"<code>task: asyncio.Future</code>  <code>property</code>","text":"<p>Get the background task.</p> <p>Usefull for adding done callbacks (add_done_callback).</p> <p>Returns:</p> Type Description <code>Future</code> <p>the background task object</p>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Asynchronous context manager, which starts the reader.</p> <p>Returns:</p> Type Description <code>Self</code> <p>AtomicLineReader instance</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Asynchronous context manager, which starts the reader.\n    Returns:\n        AtomicLineReader instance\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.__aexit__","title":"<code>__aexit__(_exc_type, _exc_val, _exc_tb)</code>  <code>async</code>","text":"<p>Close the asynchronous context manager and stop the reader.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>async def __aexit__(\nself,\n_exc_type: Type[BaseException] | None,\n_exc_val: BaseException | None,\n_exc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Close the asynchronous context manager and stop the reader.\"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.__init__","title":"<code>__init__()</code>","text":"<p>Generate a reader.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Generate a reader.\"\"\"\nself._background_task = DoneTask()\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.signal_stop","title":"<code>signal_stop()</code>","text":"<p>Request a soft stop of the background thread.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def signal_stop(self) -&gt; None:\n\"\"\"Request a soft stop of the background thread.\"\"\"\nlogger.debug(\nf\"Signaling stop to background task for {super()!r}\",\n)\nself._background_task_stop = True\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.start","title":"<code>start()</code>","text":"<p>Start the reader coroutine.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the reader coroutine.\"\"\"\nif not self.background_task_active:\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself._background_task_stop = False\nself._background_task = asyncio.create_task(self._background_job())\nself._background_task.add_done_callback(\nlambda task: self._job_exit_check(task),\n)\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.BackgroundTask.stop","title":"<code>stop(timeout=0)</code>  <code>async</code>","text":"<p>Stop the reader coroutine.</p> <p>Raises any errors which might have occured in the background task.</p> <p>Raises:</p> Type Description <code>LinesTimeoutError</code> <p>timeout occured</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>timeout in seconds before the reader process is forcefully cancelled.</p> <code>0</code> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>async def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the reader coroutine.\n    Raises any errors which might have occured in the background task.\n    Raises:\n        LinesTimeoutError: timeout occured\n    Args:\n        timeout: timeout in seconds before the reader process is forcefully\n            cancelled.\n    \"\"\"\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself.signal_stop()\nif timeout == 0:\nself._background_task.cancel()\nwith contextlib.suppress(asyncio.CancelledError):\nawait asyncio.wait_for(self._background_task, 0.1)\nreturn\ntry:\nawait asyncio.wait_for(self._background_task, timeout)\nexcept TimeoutError as timeout_exception:\nlogger.debug(\nf\"Cancelled background task for {super()!r} after {timeout} \"\n+ \"second timeout.\",\n)\nraise LinesTimeoutError(timeout) from timeout_exception\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.LineProcessor","title":"<code>LineProcessor</code>","text":"<p>             Bases: <code>BackgroundTask</code></p> <p>Run function(s) for each incomming line.</p> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>class LineProcessor(BackgroundTask):\n\"\"\"Run function(s) for each incomming line.\"\"\"\nprocessor_type: TypeAlias = Callable[\n[LineHolder],\nbool | None,  # noqa: WPS465 this is a typehint\n]\ndef __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Init.\n        Args:\n            streamable: data stream to monitor for lines.\n        \"\"\"\nself._streamable = streamable\nself._reader = AtomicLineReader(streamable)\nself._processors: list[LineProcessor.processor_type] = []\nsuper().__init__()\ndef start(self) -&gt; None:\n\"\"\"Start monitioring.\n        Whenever possible use the context manager.\n        \"\"\"\nself._reader.start()\nsuper().start()\ndef add_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Add a callable to process lines.\n        Callable will be passed the line as its only argument.\n        Callable may return a boolean value, if the callable returns true\n        processors registered later will not be presented with the current line.\n        Args:\n            processor: a callable to process each line with\n        \"\"\"\nself._processors.append(processor)\ndef remove_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Remove a processor (only the first occurance).\n        Args:\n            processor: processor which is to be removed\n        \"\"\"\nself._processors.remove(processor)\nasync def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the line processor.\n        Prefer the contextmanager whenever possible.\n        Args:\n            timeout: Time to allow for a graceful shutdown before killing.\n                Defaults to 0.\n        \"\"\"\nasync with asyncio.TaskGroup() as task_group:\ntask_group.create_task(self._reader.stop(timeout))\ntask_group.create_task(super().stop(timeout))\nasync def _background_job(self) -&gt; None:\nwhile not self._background_task_stop:\ntry:\nline = await self._reader.readline()\nexcept LinesProcessError:\nreturn\nline_object = LineHolder(line)\nfor processor in self._processors:\nlogger.debug(f\"using processor {processor} on {line!r}\")\nif processor(line_object):\nbreak\nawait asyncio.sleep(0)\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.LineProcessor.__init__","title":"<code>__init__(streamable)</code>","text":"<p>Init.</p> <p>Parameters:</p> Name Type Description Default <code>streamable</code> <code>Readable</code> <p>data stream to monitor for lines.</p> required Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Init.\n    Args:\n        streamable: data stream to monitor for lines.\n    \"\"\"\nself._streamable = streamable\nself._reader = AtomicLineReader(streamable)\nself._processors: list[LineProcessor.processor_type] = []\nsuper().__init__()\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.LineProcessor.add_processor","title":"<code>add_processor(processor)</code>","text":"<p>Add a callable to process lines.</p> <p>Callable will be passed the line as its only argument. Callable may return a boolean value, if the callable returns true processors registered later will not be presented with the current line.</p> <p>Parameters:</p> Name Type Description Default <code>processor</code> <code>processor_type</code> <p>a callable to process each line with</p> required Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def add_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Add a callable to process lines.\n    Callable will be passed the line as its only argument.\n    Callable may return a boolean value, if the callable returns true\n    processors registered later will not be presented with the current line.\n    Args:\n        processor: a callable to process each line with\n    \"\"\"\nself._processors.append(processor)\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.LineProcessor.remove_processor","title":"<code>remove_processor(processor)</code>","text":"<p>Remove a processor (only the first occurance).</p> <p>Parameters:</p> Name Type Description Default <code>processor</code> <code>processor_type</code> <p>processor which is to be removed</p> required Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def remove_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Remove a processor (only the first occurance).\n    Args:\n        processor: processor which is to be removed\n    \"\"\"\nself._processors.remove(processor)\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.LineProcessor.start","title":"<code>start()</code>","text":"<p>Start monitioring.</p> <p>Whenever possible use the context manager.</p> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start monitioring.\n    Whenever possible use the context manager.\n    \"\"\"\nself._reader.start()\nsuper().start()\n</code></pre>"},{"location":"reference/atomiclines/index.html#atomiclines.LineProcessor.stop","title":"<code>stop(timeout=0)</code>  <code>async</code>","text":"<p>Stop the line processor.</p> <p>Prefer the contextmanager whenever possible.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Time to allow for a graceful shutdown before killing. Defaults to 0.</p> <code>0</code> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>async def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the line processor.\n    Prefer the contextmanager whenever possible.\n    Args:\n        timeout: Time to allow for a graceful shutdown before killing.\n            Defaults to 0.\n    \"\"\"\nasync with asyncio.TaskGroup() as task_group:\ntask_group.create_task(self._reader.stop(timeout))\ntask_group.create_task(super().stop(timeout))\n</code></pre>"},{"location":"reference/atomiclines/atomiclinereader.html","title":"atomiclinereader","text":""},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.AtomicLineReader","title":"<code>AtomicLineReader</code>","text":"<p>             Bases: <code>BackgroundTask</code></p> <p>Read lines atomically.</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>class AtomicLineReader(BackgroundTask):\n\"\"\"Read lines atomically.\"\"\"\n_reader_task: asyncio.Task\n_reader_active: bool\n_eol: bytes\n_instances: int = 0\ndef __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Generate a reader.\n        Args:\n            streamable: object which provides an async read method, returning one byte\n        \"\"\"\nself._buffer = bytearray()  # TODO ringbuffer, that exposes a memoryview\nself._event_byte_received = asyncio.Event()\nself._streamable = streamable\nself._reader_active = False\nself._eol = b\"\\n\"\nself._instance_id = self._instances\nAtomicLineReader._instances += 1  # noqa: WPS437 - \"private\" access is intended\nsuper().__init__()\n# TODO: allow setting a default timeout\n@property\ndef buffer(self) -&gt; bytes:\n\"\"\"Peek the byte buffer.\n        Returns:\n            bytes currently held in buffer\n        \"\"\"\nreturn self._buffer\nasync def readline(self, timeout: float | None = None) -&gt; bytes:\n\"\"\"Read a single line or raise a timeout error.\n        Args:\n            timeout: timeout in seconds. Defaults to None.\n        Raises:\n            LinesTimeoutError: if the buffer does not contain an end of line character\n                before the timeout expires\n        Returns:\n            the next line from the buffer (!without the eol character)\n        \"\"\"\n# TODO: should we return a Timeout error or an IncompleteReadError?\nif timeout == 0:\nif self._buffer.find(self._eol) == -1:\nraise LinesTimeoutError(timeout)\n# TODO: asyncio.IncompleteReadError(self._buffer.copy(), None)\nelse:\nawait self._wait_for_line(timeout)\nline, _, buffer = self._buffer.partition(self._eol)\nself._buffer = buffer\nreturn line\ndef start(self) -&gt; None:\n\"\"\"Start the background reader process.\n        Prefer using this as a context manager whenever you can.\n        \"\"\"\nsuper().start()\nself.task.add_done_callback(lambda task: self._event_byte_received.set())\nasync def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop reading.\n        Args:\n            timeout: Timeout for a gracefull shutdown. Defaults to 0.\n        \"\"\"\nself.signal_stop()\nawait super().stop(timeout)\nasync def _background_job(self) -&gt; None:\nwhile not self._background_task_stop:\nbytes_read = await self._streamable.read()\nself._buffer.extend(bytes_read)\nif self._eol in bytes_read:\nold_data_end = -len(bytes_read)\nline_start = self._buffer.rfind(self._eol, None, old_data_end) + 1\nline_end = self._buffer.find(self._eol, line_start)\nwhile line_end != -1:\nlogger.info(bytes(self._buffer[line_start:line_end]))\nline_start = line_end + 1\nline_end = self._buffer.find(self._eol, line_start)\nself._event_byte_received.set()\nasync def _wait_for_line(self, timeout: float | None = None) -&gt; None:\nasync with asyncio.timeout(timeout):\nwhile self._buffer.find(self._eol) == -1:\nawait self._event_byte_received.wait()\nself._event_byte_received.clear()\nif not self.background_task_active:\nraise LinesProcessError()\n</code></pre>"},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.AtomicLineReader.buffer","title":"<code>buffer: bytes</code>  <code>property</code>","text":"<p>Peek the byte buffer.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes currently held in buffer</p>"},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.AtomicLineReader.__init__","title":"<code>__init__(streamable)</code>","text":"<p>Generate a reader.</p> <p>Parameters:</p> Name Type Description Default <code>streamable</code> <code>Readable</code> <p>object which provides an async read method, returning one byte</p> required Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>def __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Generate a reader.\n    Args:\n        streamable: object which provides an async read method, returning one byte\n    \"\"\"\nself._buffer = bytearray()  # TODO ringbuffer, that exposes a memoryview\nself._event_byte_received = asyncio.Event()\nself._streamable = streamable\nself._reader_active = False\nself._eol = b\"\\n\"\nself._instance_id = self._instances\nAtomicLineReader._instances += 1  # noqa: WPS437 - \"private\" access is intended\nsuper().__init__()\n</code></pre>"},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.AtomicLineReader.readline","title":"<code>readline(timeout=None)</code>  <code>async</code>","text":"<p>Read a single line or raise a timeout error.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>timeout in seconds. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>LinesTimeoutError</code> <p>if the buffer does not contain an end of line character before the timeout expires</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the next line from the buffer (!without the eol character)</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>async def readline(self, timeout: float | None = None) -&gt; bytes:\n\"\"\"Read a single line or raise a timeout error.\n    Args:\n        timeout: timeout in seconds. Defaults to None.\n    Raises:\n        LinesTimeoutError: if the buffer does not contain an end of line character\n            before the timeout expires\n    Returns:\n        the next line from the buffer (!without the eol character)\n    \"\"\"\n# TODO: should we return a Timeout error or an IncompleteReadError?\nif timeout == 0:\nif self._buffer.find(self._eol) == -1:\nraise LinesTimeoutError(timeout)\n# TODO: asyncio.IncompleteReadError(self._buffer.copy(), None)\nelse:\nawait self._wait_for_line(timeout)\nline, _, buffer = self._buffer.partition(self._eol)\nself._buffer = buffer\nreturn line\n</code></pre>"},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.AtomicLineReader.start","title":"<code>start()</code>","text":"<p>Start the background reader process.</p> <p>Prefer using this as a context manager whenever you can.</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the background reader process.\n    Prefer using this as a context manager whenever you can.\n    \"\"\"\nsuper().start()\nself.task.add_done_callback(lambda task: self._event_byte_received.set())\n</code></pre>"},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.AtomicLineReader.stop","title":"<code>stop(timeout=0)</code>  <code>async</code>","text":"<p>Stop reading.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Timeout for a gracefull shutdown. Defaults to 0.</p> <code>0</code> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>async def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop reading.\n    Args:\n        timeout: Timeout for a gracefull shutdown. Defaults to 0.\n    \"\"\"\nself.signal_stop()\nawait super().stop(timeout)\n</code></pre>"},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.Readable","title":"<code>Readable</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Readable protocol.</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>class Readable(typing.Protocol):\n\"\"\"Readable protocol.\"\"\"\nasync def read(self) -&gt; bytes:\n\"\"\"Read one byte.\"\"\"\n</code></pre>"},{"location":"reference/atomiclines/atomiclinereader.html#atomiclines.atomiclinereader.Readable.read","title":"<code>read()</code>  <code>async</code>","text":"<p>Read one byte.</p> Source code in <code>src/atomiclines/atomiclinereader.py</code> <pre><code>async def read(self) -&gt; bytes:\n\"\"\"Read one byte.\"\"\"\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html","title":"backgroundtask","text":""},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask","title":"<code>BackgroundTask</code>","text":"<p>Read lines atomically.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>class BackgroundTask:\n\"\"\"Read lines atomically.\"\"\"\n_background_task: asyncio.Task | asyncio.Future\ndef __init__(self) -&gt; None:\n\"\"\"Generate a reader.\"\"\"\nself._background_task = DoneTask()\n@property\ndef background_task_active(self) -&gt; bool:\n\"\"\"Check if the background task is (still) running.\n        Returns:\n            bool indication if the background task is running.\n        \"\"\"\nreturn not self._background_task.done()\ndef start(self) -&gt; None:\n\"\"\"Start the reader coroutine.\"\"\"\nif not self.background_task_active:\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself._background_task_stop = False\nself._background_task = asyncio.create_task(self._background_job())\nself._background_task.add_done_callback(\nlambda task: self._job_exit_check(task),\n)\ndef signal_stop(self) -&gt; None:\n\"\"\"Request a soft stop of the background thread.\"\"\"\nlogger.debug(\nf\"Signaling stop to background task for {super()!r}\",\n)\nself._background_task_stop = True\nasync def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the reader coroutine.\n        Raises any errors which might have occured in the background task.\n        Raises:\n            LinesTimeoutError: timeout occured\n        Args:\n            timeout: timeout in seconds before the reader process is forcefully\n                cancelled.\n        \"\"\"\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself.signal_stop()\nif timeout == 0:\nself._background_task.cancel()\nwith contextlib.suppress(asyncio.CancelledError):\nawait asyncio.wait_for(self._background_task, 0.1)\nreturn\ntry:\nawait asyncio.wait_for(self._background_task, timeout)\nexcept TimeoutError as timeout_exception:\nlogger.debug(\nf\"Cancelled background task for {super()!r} after {timeout} \"\n+ \"second timeout.\",\n)\nraise LinesTimeoutError(timeout) from timeout_exception\n@property\ndef task(self) -&gt; asyncio.Future:\n\"\"\"Get the background task.\n        Usefull for adding done callbacks (add_done_callback).\n        Returns:\n            the background task object\n        \"\"\"\nreturn self._background_task\nasync def __aenter__(self) -&gt; Self:\n\"\"\"Asynchronous context manager, which starts the reader.\n        Returns:\n            AtomicLineReader instance\n        \"\"\"\nself.start()\nreturn self\nasync def __aexit__(\nself,\n_exc_type: Type[BaseException] | None,\n_exc_val: BaseException | None,\n_exc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Close the asynchronous context manager and stop the reader.\"\"\"\nawait self.stop()\n# @abstractmethod\nasync def _background_job(self) -&gt; None:\n\"\"\"Function to run in the background (as an Asyncio task).\n        A typical implemntation should check on self._background_task_stop,\n        since this is used to signal a soft stop.\n        while not self._background_task_stop:\n            doSomething()\n        Raises:\n            NotImplementedError: _description_\n        \"\"\"  # noqa: D401\nraise NotImplementedError\ndef _job_exit_check(self, task: asyncio.Task) -&gt; None:\nwith contextlib.suppress(asyncio.CancelledError):\nif task.exception() is not None:\nlogger.error(\nf\"An error occured in the background process. {task.exception()}\",\n)\nlogger.error(traceback.format_exception(task.exception()))\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.background_task_active","title":"<code>background_task_active: bool</code>  <code>property</code>","text":"<p>Check if the background task is (still) running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool indication if the background task is running.</p>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.task","title":"<code>task: asyncio.Future</code>  <code>property</code>","text":"<p>Get the background task.</p> <p>Usefull for adding done callbacks (add_done_callback).</p> <p>Returns:</p> Type Description <code>Future</code> <p>the background task object</p>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Asynchronous context manager, which starts the reader.</p> <p>Returns:</p> Type Description <code>Self</code> <p>AtomicLineReader instance</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n\"\"\"Asynchronous context manager, which starts the reader.\n    Returns:\n        AtomicLineReader instance\n    \"\"\"\nself.start()\nreturn self\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.__aexit__","title":"<code>__aexit__(_exc_type, _exc_val, _exc_tb)</code>  <code>async</code>","text":"<p>Close the asynchronous context manager and stop the reader.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>async def __aexit__(\nself,\n_exc_type: Type[BaseException] | None,\n_exc_val: BaseException | None,\n_exc_tb: TracebackType | None,\n) -&gt; None:\n\"\"\"Close the asynchronous context manager and stop the reader.\"\"\"\nawait self.stop()\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.__init__","title":"<code>__init__()</code>","text":"<p>Generate a reader.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Generate a reader.\"\"\"\nself._background_task = DoneTask()\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.signal_stop","title":"<code>signal_stop()</code>","text":"<p>Request a soft stop of the background thread.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def signal_stop(self) -&gt; None:\n\"\"\"Request a soft stop of the background thread.\"\"\"\nlogger.debug(\nf\"Signaling stop to background task for {super()!r}\",\n)\nself._background_task_stop = True\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.start","title":"<code>start()</code>","text":"<p>Start the reader coroutine.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start the reader coroutine.\"\"\"\nif not self.background_task_active:\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself._background_task_stop = False\nself._background_task = asyncio.create_task(self._background_job())\nself._background_task.add_done_callback(\nlambda task: self._job_exit_check(task),\n)\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.BackgroundTask.stop","title":"<code>stop(timeout=0)</code>  <code>async</code>","text":"<p>Stop the reader coroutine.</p> <p>Raises any errors which might have occured in the background task.</p> <p>Raises:</p> Type Description <code>LinesTimeoutError</code> <p>timeout occured</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>timeout in seconds before the reader process is forcefully cancelled.</p> <code>0</code> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>async def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the reader coroutine.\n    Raises any errors which might have occured in the background task.\n    Raises:\n        LinesTimeoutError: timeout occured\n    Args:\n        timeout: timeout in seconds before the reader process is forcefully\n            cancelled.\n    \"\"\"\nlogger.debug(\nf\"Starting  background task for {super()!r}\",\n)\nself.signal_stop()\nif timeout == 0:\nself._background_task.cancel()\nwith contextlib.suppress(asyncio.CancelledError):\nawait asyncio.wait_for(self._background_task, 0.1)\nreturn\ntry:\nawait asyncio.wait_for(self._background_task, timeout)\nexcept TimeoutError as timeout_exception:\nlogger.debug(\nf\"Cancelled background task for {super()!r} after {timeout} \"\n+ \"second timeout.\",\n)\nraise LinesTimeoutError(timeout) from timeout_exception\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.DoneTask","title":"<code>DoneTask</code>","text":"<p>             Bases: <code>Future</code></p> <p>A Future which has completed.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>class DoneTask(asyncio.Future):\n\"\"\"A Future which has completed.\"\"\"\ndef __init__(self, future_result: Any = None) -&gt; None:\n\"\"\"Initialize completed Future.\n        Args:\n            future_result: Future return value. Defaults to None.\n        \"\"\"\nsuper().__init__()\nself.set_result(future_result)\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.DoneTask.__init__","title":"<code>__init__(future_result=None)</code>","text":"<p>Initialize completed Future.</p> <p>Parameters:</p> Name Type Description Default <code>future_result</code> <code>Any</code> <p>Future return value. Defaults to None.</p> <code>None</code> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def __init__(self, future_result: Any = None) -&gt; None:\n\"\"\"Initialize completed Future.\n    Args:\n        future_result: Future return value. Defaults to None.\n    \"\"\"\nsuper().__init__()\nself.set_result(future_result)\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.Readable","title":"<code>Readable</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Readable protocol.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>class Readable(Protocol):\n\"\"\"Readable protocol.\"\"\"\ndef read(self) -&gt; bytes:\n\"\"\"Read one byte.\"\"\"\n</code></pre>"},{"location":"reference/atomiclines/backgroundtask.html#atomiclines.backgroundtask.Readable.read","title":"<code>read()</code>","text":"<p>Read one byte.</p> Source code in <code>src/atomiclines/backgroundtask.py</code> <pre><code>def read(self) -&gt; bytes:\n\"\"\"Read one byte.\"\"\"\n</code></pre>"},{"location":"reference/atomiclines/exception.html","title":"exception","text":""},{"location":"reference/atomiclines/exception.html#atomiclines.exception.LinesException","title":"<code>LinesException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base exception class for atomiclines library.</p> Source code in <code>src/atomiclines/exception.py</code> <pre><code>class LinesException(Exception):\n\"\"\"Base exception class for atomiclines library.\"\"\"\n</code></pre>"},{"location":"reference/atomiclines/exception.html#atomiclines.exception.LinesProcessError","title":"<code>LinesProcessError</code>","text":"<p>             Bases: <code>LinesException</code></p> <p>Errors generated by a lines process.</p> Source code in <code>src/atomiclines/exception.py</code> <pre><code>class LinesProcessError(LinesException):\n\"\"\"Errors generated by a lines process.\"\"\"\n</code></pre>"},{"location":"reference/atomiclines/exception.html#atomiclines.exception.LinesTimeoutError","title":"<code>LinesTimeoutError</code>","text":"<p>             Bases: <code>LinesException</code></p> <p>Timeout exception.</p> <p>Stores the timeout in seconds which elapsed.</p> Source code in <code>src/atomiclines/exception.py</code> <pre><code>class LinesTimeoutError(LinesException):\n\"\"\"Timeout exception.\n    Stores the timeout in seconds which elapsed.\n    \"\"\"\ndef __init__(self, timeout: float) -&gt; None:\n\"\"\"Initialize new timeout exception.\n        Args:\n            timeout: timeout in seconds.\n        \"\"\"\nself._timeout = timeout\nsuper().__init__(timeout)\n@property\ndef timeout(self) -&gt; float:\n\"\"\"Timeout as a read only property.\n        Returns:\n            timeout in seconds.\n        \"\"\"\nreturn self._timeout\ndef __str__(self) -&gt; str:\n\"\"\"Generate String representation.\n        Returns:\n            string representation.\n        \"\"\"\nreturn f\"Timeout of {self.timeout} seconds expired.\"\n</code></pre>"},{"location":"reference/atomiclines/exception.html#atomiclines.exception.LinesTimeoutError.timeout","title":"<code>timeout: float</code>  <code>property</code>","text":"<p>Timeout as a read only property.</p> <p>Returns:</p> Type Description <code>float</code> <p>timeout in seconds.</p>"},{"location":"reference/atomiclines/exception.html#atomiclines.exception.LinesTimeoutError.__init__","title":"<code>__init__(timeout)</code>","text":"<p>Initialize new timeout exception.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>timeout in seconds.</p> required Source code in <code>src/atomiclines/exception.py</code> <pre><code>def __init__(self, timeout: float) -&gt; None:\n\"\"\"Initialize new timeout exception.\n    Args:\n        timeout: timeout in seconds.\n    \"\"\"\nself._timeout = timeout\nsuper().__init__(timeout)\n</code></pre>"},{"location":"reference/atomiclines/exception.html#atomiclines.exception.LinesTimeoutError.__str__","title":"<code>__str__()</code>","text":"<p>Generate String representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>string representation.</p> Source code in <code>src/atomiclines/exception.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Generate String representation.\n    Returns:\n        string representation.\n    \"\"\"\nreturn f\"Timeout of {self.timeout} seconds expired.\"\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html","title":"lineprocessor","text":""},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineHolder","title":"<code>LineHolder</code>","text":"<p>Class passed between the processor function on a LineProcessor.</p> <p>Allows either modifying the line, or adding additonal properties.</p> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>class LineHolder:\n\"\"\"Class passed between the processor function on a LineProcessor.\n    Allows either modifying the line, or adding additonal properties.\n    \"\"\"\ndef __init__(self, line: bytes) -&gt; None:\n\"\"\"Init.\n        Args:\n            line: the initial line\n        \"\"\"\nself.line = line\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"Comparison function.\n        Args:\n            other: object to compare against\n        Returns:\n            true if all instance properties are equal and a subclass of LineHolder\n        \"\"\"\nif isinstance(other, self.__class__):\nreturn self.__dict__ == other.__dict__\nreturn False\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineHolder.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Comparison function.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>object to compare against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>true if all instance properties are equal and a subclass of LineHolder</p> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Comparison function.\n    Args:\n        other: object to compare against\n    Returns:\n        true if all instance properties are equal and a subclass of LineHolder\n    \"\"\"\nif isinstance(other, self.__class__):\nreturn self.__dict__ == other.__dict__\nreturn False\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineHolder.__init__","title":"<code>__init__(line)</code>","text":"<p>Init.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>bytes</code> <p>the initial line</p> required Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def __init__(self, line: bytes) -&gt; None:\n\"\"\"Init.\n    Args:\n        line: the initial line\n    \"\"\"\nself.line = line\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineProcessor","title":"<code>LineProcessor</code>","text":"<p>             Bases: <code>BackgroundTask</code></p> <p>Run function(s) for each incomming line.</p> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>class LineProcessor(BackgroundTask):\n\"\"\"Run function(s) for each incomming line.\"\"\"\nprocessor_type: TypeAlias = Callable[\n[LineHolder],\nbool | None,  # noqa: WPS465 this is a typehint\n]\ndef __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Init.\n        Args:\n            streamable: data stream to monitor for lines.\n        \"\"\"\nself._streamable = streamable\nself._reader = AtomicLineReader(streamable)\nself._processors: list[LineProcessor.processor_type] = []\nsuper().__init__()\ndef start(self) -&gt; None:\n\"\"\"Start monitioring.\n        Whenever possible use the context manager.\n        \"\"\"\nself._reader.start()\nsuper().start()\ndef add_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Add a callable to process lines.\n        Callable will be passed the line as its only argument.\n        Callable may return a boolean value, if the callable returns true\n        processors registered later will not be presented with the current line.\n        Args:\n            processor: a callable to process each line with\n        \"\"\"\nself._processors.append(processor)\ndef remove_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Remove a processor (only the first occurance).\n        Args:\n            processor: processor which is to be removed\n        \"\"\"\nself._processors.remove(processor)\nasync def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the line processor.\n        Prefer the contextmanager whenever possible.\n        Args:\n            timeout: Time to allow for a graceful shutdown before killing.\n                Defaults to 0.\n        \"\"\"\nasync with asyncio.TaskGroup() as task_group:\ntask_group.create_task(self._reader.stop(timeout))\ntask_group.create_task(super().stop(timeout))\nasync def _background_job(self) -&gt; None:\nwhile not self._background_task_stop:\ntry:\nline = await self._reader.readline()\nexcept LinesProcessError:\nreturn\nline_object = LineHolder(line)\nfor processor in self._processors:\nlogger.debug(f\"using processor {processor} on {line!r}\")\nif processor(line_object):\nbreak\nawait asyncio.sleep(0)\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineProcessor.__init__","title":"<code>__init__(streamable)</code>","text":"<p>Init.</p> <p>Parameters:</p> Name Type Description Default <code>streamable</code> <code>Readable</code> <p>data stream to monitor for lines.</p> required Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def __init__(self, streamable: Readable) -&gt; None:\n\"\"\"Init.\n    Args:\n        streamable: data stream to monitor for lines.\n    \"\"\"\nself._streamable = streamable\nself._reader = AtomicLineReader(streamable)\nself._processors: list[LineProcessor.processor_type] = []\nsuper().__init__()\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineProcessor.add_processor","title":"<code>add_processor(processor)</code>","text":"<p>Add a callable to process lines.</p> <p>Callable will be passed the line as its only argument. Callable may return a boolean value, if the callable returns true processors registered later will not be presented with the current line.</p> <p>Parameters:</p> Name Type Description Default <code>processor</code> <code>processor_type</code> <p>a callable to process each line with</p> required Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def add_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Add a callable to process lines.\n    Callable will be passed the line as its only argument.\n    Callable may return a boolean value, if the callable returns true\n    processors registered later will not be presented with the current line.\n    Args:\n        processor: a callable to process each line with\n    \"\"\"\nself._processors.append(processor)\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineProcessor.remove_processor","title":"<code>remove_processor(processor)</code>","text":"<p>Remove a processor (only the first occurance).</p> <p>Parameters:</p> Name Type Description Default <code>processor</code> <code>processor_type</code> <p>processor which is to be removed</p> required Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def remove_processor(self, processor: processor_type) -&gt; None:\n\"\"\"Remove a processor (only the first occurance).\n    Args:\n        processor: processor which is to be removed\n    \"\"\"\nself._processors.remove(processor)\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineProcessor.start","title":"<code>start()</code>","text":"<p>Start monitioring.</p> <p>Whenever possible use the context manager.</p> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Start monitioring.\n    Whenever possible use the context manager.\n    \"\"\"\nself._reader.start()\nsuper().start()\n</code></pre>"},{"location":"reference/atomiclines/lineprocessor.html#atomiclines.lineprocessor.LineProcessor.stop","title":"<code>stop(timeout=0)</code>  <code>async</code>","text":"<p>Stop the line processor.</p> <p>Prefer the contextmanager whenever possible.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Time to allow for a graceful shutdown before killing. Defaults to 0.</p> <code>0</code> Source code in <code>src/atomiclines/lineprocessor.py</code> <pre><code>async def stop(self, timeout: float = 0) -&gt; None:\n\"\"\"Stop the line processor.\n    Prefer the contextmanager whenever possible.\n    Args:\n        timeout: Time to allow for a graceful shutdown before killing.\n            Defaults to 0.\n    \"\"\"\nasync with asyncio.TaskGroup() as task_group:\ntask_group.create_task(self._reader.stop(timeout))\ntask_group.create_task(super().stop(timeout))\n</code></pre>"},{"location":"reference/atomiclines/log.html","title":"log","text":""},{"location":"reference/atomiclines/log.html#atomiclines.log.load_config_from_yaml","title":"<code>load_config_from_yaml(config_file_path)</code>","text":"<p>Load configuration from file.</p> <p>Parameters:</p> Name Type Description Default <code>config_file_path</code> <code>str | PathLike</code> <p>description</p> required Source code in <code>src/atomiclines/log.py</code> <pre><code>def load_config_from_yaml(config_file_path: str | os.PathLike) -&gt; None:\n\"\"\"Load configuration from file.\n    Args:\n        config_file_path: _description_\n    \"\"\"\nconfig_file = Path(config_file_path)\n# Let this throw, if the config file does not exist, you want to know.\n# ... and logging is not configured as you expect yet, so logging is not\n# an option\nconfiguration = yaml.safe_load(config_file.read_text(encoding=\"utf-8\"))\nDictConfigurator(configuration).configure()\n</code></pre>"},{"location":"reference/atomiclines/log.html#atomiclines.log.try_load_config_from_environment","title":"<code>try_load_config_from_environment(environment_variable)</code>","text":"<p>Load configuration from file specified in environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>environment_variable</code> <code>str</code> <p>name of environment variable holding path to config file.</p> required Source code in <code>src/atomiclines/log.py</code> <pre><code>def try_load_config_from_environment(environment_variable: str) -&gt; None:\n\"\"\"Load configuration from file specified in environment variable.\n    Args:\n        environment_variable: name of environment variable holding path to config file.\n    \"\"\"\nconfig_file_path = os.environ.get(environment_variable, None)\nif config_file_path:\nload_config_from_yaml(config_file_path)\n</code></pre>"}]}